## *Deadlock*
###一、实验代码
#####环境：windows操作系统
![](https://ooo.0o0.ooo/2016/11/11/5825b2a733180.png)
![](https://ooo.0o0.ooo/2016/11/11/5825b2af584a6.png)
###二、实验截图
#####1、count = 20000：
![](https://ooo.0o0.ooo/2016/11/11/5825b2b4b03cc.png)
######由图可知：程序在运行到17次的时候就发生了死锁。
#####2、count = 200000 ：
![](https://ooo.0o0.ooo/2016/11/11/5825b2c480086.png)
######由图可知：程序在运行到136次的时候就发生了死锁。
###三、产生死锁的四个必要条件：
#####（1）互斥条件：一个资源每次只能被一个进程使用
#####（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
#####（3）不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
#####（4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系
###四、实验程序产生死锁的解释：
#####&#160; &#160; &#160; &#160;首先观察代码我们就能发现synchronized的a.method(b)请求synchronized的b.last()，synchronized的b.method(a)请求synchronized的a.last()。然后主线程是请求a.method(b)而线程t是请求b.method(a)。接着多次循环就会有可能出现主线程和线程t同时发出请求，所以两者就会发生都在等待对方释放资源，因此这时候就出现了死锁。